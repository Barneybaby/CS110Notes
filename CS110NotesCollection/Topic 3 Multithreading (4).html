<!DOCTYPE html>
<html>
    <head>
		<title>Multithrd (4)</title>
		<link rel="icon" href="../CS110Notes_icon.png">
        <meta http-equiv="Content-type" content="text/html;charset=UTF-8">
        <style>
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/

body {
	font-family: "Segoe WPC", "Segoe UI", "SFUIText-Light", "HelveticaNeue-Light", sans-serif, "Droid Sans Fallback";
	font-size: 14px;
	padding: 0 26px;
	line-height: 22px;
	word-wrap: break-word;
}

#code-csp-warning {
	position: fixed;
	top: 0;
	right: 0;
	color: white;
	margin: 16px;
	text-align: center;
	font-size: 12px;
	font-family: sans-serif;
	background-color:#444444;
	cursor: pointer;
	padding: 6px;
	box-shadow: 1px 1px 1px rgba(0,0,0,.25);
}

#code-csp-warning:hover {
	text-decoration: none;
	background-color:#007acc;
	box-shadow: 2px 2px 2px rgba(0,0,0,.25);
}


body.scrollBeyondLastLine {
	margin-bottom: calc(100vh - 22px);
}

body.showEditorSelection .code-line {
	position: relative;
}

body.showEditorSelection .code-active-line:before,
body.showEditorSelection .code-line:hover:before {
	content: "";
	display: block;
	position: absolute;
	top: 0;
	left: -12px;
	height: 100%;
}

body.showEditorSelection li.code-active-line:before,
body.showEditorSelection li.code-line:hover:before {
	left: -30px;
}

.vscode-light.showEditorSelection .code-active-line:before {
	border-left: 3px solid rgba(0, 0, 0, 0.15);
}

.vscode-light.showEditorSelection .code-line:hover:before {
	border-left: 3px solid rgba(0, 0, 0, 0.40);
}

.vscode-light.showEditorSelection .code-line .code-line:hover:before {
	border-left: none;
}

.vscode-dark.showEditorSelection .code-active-line:before {
	border-left: 3px solid rgba(255, 255, 255, 0.4);
}

.vscode-dark.showEditorSelection .code-line:hover:before {
	border-left: 3px solid rgba(255, 255, 255, 0.60);
}

.vscode-dark.showEditorSelection .code-line .code-line:hover:before {
	border-left: none;
}

.vscode-high-contrast.showEditorSelection .code-active-line:before {
	border-left: 3px solid rgba(255, 160, 0, 0.7);
}

.vscode-high-contrast.showEditorSelection .code-line:hover:before {
	border-left: 3px solid rgba(255, 160, 0, 1);
}

.vscode-high-contrast.showEditorSelection .code-line .code-line:hover:before {
	border-left: none;
}

img {
	max-width: 100%;
	max-height: 100%;
}

a {
	color: #4080D0;
	text-decoration: none;
}

a:focus,
input:focus,
select:focus,
textarea:focus {
	outline: 1px solid -webkit-focus-ring-color;
	outline-offset: -1px;
}

hr {
	border: 0;
	height: 2px;
	border-bottom: 2px solid;
}

h1 {
	padding-bottom: 0.3em;
	line-height: 1.2;
	border-bottom-width: 1px;
	border-bottom-style: solid;
}

h1, h2, h3 {
	font-weight: normal;
}

h1 code,
h2 code,
h3 code,
h4 code,
h5 code,
h6 code {
	font-size: inherit;
	line-height: auto;
}

a:hover {
	color: #4080D0;
	text-decoration: underline;
}

table {
	border-collapse: collapse;
}

table > thead > tr > th {
	text-align: left;
	border-bottom: 1px solid;
}

table > thead > tr > th,
table > thead > tr > td,
table > tbody > tr > th,
table > tbody > tr > td {
	padding: 5px 10px;
}

table > tbody > tr + tr > td {
	border-top: 1px solid;
}

blockquote {
	margin: 0 7px 0 5px;
	padding: 0 16px 0 10px;
	border-left: 5px solid;
}

code {
	font-family: Menlo, Monaco, Consolas, "Droid Sans Mono", "Courier New", monospace, "Droid Sans Fallback";
	font-size: 14px;
	line-height: 19px;
}

body.wordWrap pre {
	white-space: pre-wrap;
}

.mac code {
	font-size: 12px;
	line-height: 18px;
}

pre:not(.hljs),
pre.hljs code > div {
	padding: 16px;
	border-radius: 3px;
	overflow: auto;
}

/** Theming */

.vscode-light,
.vscode-light pre code {
	color: rgb(30, 30, 30);
}

.vscode-dark,
.vscode-dark pre code {
	color: #DDD;
}

.vscode-high-contrast,
.vscode-high-contrast pre code {
	color: white;
}

.vscode-light code {
	color: #A31515;
}

.vscode-dark code {
	color: #D7BA7D;
}

.vscode-light pre:not(.hljs),
.vscode-light code > div {
	background-color: rgba(220, 220, 220, 0.4);
}

.vscode-dark pre:not(.hljs),
.vscode-dark code > div {
	background-color: rgba(10, 10, 10, 0.4);
}

.vscode-high-contrast pre:not(.hljs),
.vscode-high-contrast code > div {
	background-color: rgb(0, 0, 0);
}

.vscode-high-contrast h1 {
	border-color: rgb(0, 0, 0);
}

.vscode-light table > thead > tr > th {
	border-color: rgba(0, 0, 0, 0.69);
}

.vscode-dark table > thead > tr > th {
	border-color: rgba(255, 255, 255, 0.69);
}

.vscode-light h1,
.vscode-light hr,
.vscode-light table > tbody > tr + tr > td {
	border-color: rgba(0, 0, 0, 0.18);
}

.vscode-dark h1,
.vscode-dark hr,
.vscode-dark table > tbody > tr + tr > td {
	border-color: rgba(255, 255, 255, 0.18);
}

.vscode-light blockquote,
.vscode-dark blockquote {
	background: rgba(127, 127, 127, 0.1);
	border-color: rgba(0, 122, 204, 0.5);
}

.vscode-high-contrast blockquote {
	background: transparent;
	border-color: #fff;
}
/* Tomorrow Theme */
/* http://jmblog.github.com/color-themes-for-google-code-highlightjs */
/* Original theme - https://github.com/chriskempson/tomorrow-theme */

/* Tomorrow Comment */
.hljs-comment,
.hljs-quote {
	color: #8e908c;
}

/* Tomorrow Red */
.hljs-variable,
.hljs-template-variable,
.hljs-tag,
.hljs-name,
.hljs-selector-id,
.hljs-selector-class,
.hljs-regexp,
.hljs-deletion {
	color: #c82829;
}

/* Tomorrow Orange */
.hljs-number,
.hljs-built_in,
.hljs-builtin-name,
.hljs-literal,
.hljs-type,
.hljs-params,
.hljs-meta,
.hljs-link {
	color: #f5871f;
}

/* Tomorrow Yellow */
.hljs-attribute {
	color: #eab700;
}

/* Tomorrow Green */
.hljs-string,
.hljs-symbol,
.hljs-bullet,
.hljs-addition {
	color: #718c00;
}

/* Tomorrow Blue */
.hljs-title,
.hljs-section {
	color: #4271ae;
}

/* Tomorrow Purple */
.hljs-keyword,
.hljs-selector-tag {
	color: #8959a8;
}

.hljs {
	display: block;
	overflow-x: auto;
	color: #4d4d4c;
	padding: 0.5em;
}

.hljs-emphasis {
	font-style: italic;
}

.hljs-strong {
	font-weight: bold;
}
body
{
    background-color: white;
}
.emoji
{
    height: 20px;
}
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
/* Modification based on the original version is made. */

body {
	font-family: "Segoe WPC", "Segoe UI", "SFUIText-Light", "HelveticaNeue-Light", sans-serif, "Droid Sans Fallback";
	font-size: 14px;
	padding: 0 12px;
	line-height: 22px;
	word-wrap: break-word;
	margin:0px auto;
	width:670px;
	background-color: #f5f5f5
}

#author-signature {
	text-align: right;
}

#code-csp-warning {
	position: fixed;
	top: 0;
	right: 0;
	color: white;
	margin: 16px;
	text-align: center;
	font-size: 12px;
	font-family: sans-serif;
	background-color:#444444;
	cursor: pointer;
	padding: 6px;
	box-shadow: 1px 1px 1px rgba(0,0,0,.25);
}

#code-csp-warning:hover {
	text-decoration: none;
	background-color:#007acc;
	box-shadow: 2px 2px 2px rgba(0,0,0,.25);
}


body.scrollBeyondLastLine {
	margin-bottom: calc(100vh - 22px);
}

body.showEditorSelection .code-line {
	position: relative;
}

body.showEditorSelection .code-active-line:before,
body.showEditorSelection .code-line:hover:before {
	content: "";
	display: block;
	position: absolute;
	top: 0;
	left: -12px;
	height: 100%;
}

body.showEditorSelection li.code-active-line:before,
body.showEditorSelection li.code-line:hover:before {
	left: -30px;
}

.vscode-light.showEditorSelection .code-active-line:before {
	border-left: 3px solid rgba(0, 0, 0, 0.15);
}

.vscode-light.showEditorSelection .code-line:hover:before {
	border-left: 3px solid rgba(0, 0, 0, 0.40);
}

.vscode-dark.showEditorSelection .code-active-line:before {
	border-left: 3px solid rgba(255, 255, 255, 0.4);
}

.vscode-dark.showEditorSelection .code-line:hover:before {
	border-left: 3px solid rgba(255, 255, 255, 0.60);
}

.vscode-high-contrast.showEditorSelection .code-active-line:before {
	border-left: 3px solid rgba(255, 160, 0, 0.7);
}

.vscode-high-contrast.showEditorSelection .code-line:hover:before {
	border-left: 3px solid rgba(255, 160, 0, 1);
}

img {
	max-width: 100%;
	max-height: 100%;
}

a {
	color: #4080D0;
	text-decoration: none;
}

a:focus,
input:focus,
select:focus,
textarea:focus {
	outline: 1px solid -webkit-focus-ring-color;
	outline-offset: -1px;
}

hr {
	border: 0;
	height: 2px;
	border-bottom: 2px solid;
}

h1 {
	padding-bottom: 0.3em;
	line-height: 1.2;
	border-bottom-width: 1px;
	border-bottom-style: solid;
}

h1, h2, h3 {
	font-weight: normal;
}

h1 code,
h2 code,
h3 code,
h4 code,
h5 code,
h6 code {
	font-size: inherit;
	line-height: auto;
}

a:hover {
	color: #4080D0;
	text-decoration: underline;
}

table {
	border-collapse: collapse;
}

table > thead > tr > th {
	text-align: left;
	border-bottom: 1px solid;
}

table > thead > tr > th,
table > thead > tr > td,
table > tbody > tr > th,
table > tbody > tr > td {
	padding: 5px 10px;
}

table > tbody > tr + tr > td {
	border-top: 1px solid;
}

blockquote {
	margin: 0 7px 0 5px;
	padding: 0 16px 0 10px;
	border-left: 5px solid;
}

code {
	font-family: Menlo, Monaco, Consolas, "Courier New", monospace, "Droid Sans Mono", "Droid Sans Fallback";
	font-size: 14px;
	line-height: 19px;
	color: #1e1e1e;
}

body.wordWrap pre {
	white-space: pre-wrap;
}

.mac code {
	font-size: 12px;
	line-height: 18px;
}

pre:not(.hljs),
pre.hljs code > div {
	padding: 16px;
	border-radius: 3px;
	overflow: auto;
}

/** Theming */

.vscode-light,
.vscode-light pre code {
	color: rgb(30, 30, 30);
}

.vscode-dark,
.vscode-dark pre code {
	color: #DDD;
}

.vscode-high-contrast,
.vscode-high-contrast pre code {
	color: white;
}

.vscode-light code { /* all code, including code block and inline code */
	font-family: "Courier New", monospace, Menlo, Monaco, Consolas, "Droid Sans Mono", "Droid Sans Fallback";
	/* font-family: Menlo, Monaco, Consolas, "Courier New", monospace, "Droid Sans Mono", "Droid Sans Fallback"; */
	font-weight: bold;
	/* font-weight: normal */
	color: #2a232d;
	/* color: #4080D0;*/
	background-color: #ececec;
	/* background-color: transparent; */
}

.vscode-dark code { /* all code, including code block and inline code */
	font-family: "Courier New", monospace, Menlo, Monaco, Consolas, "Droid Sans Mono", "Droid Sans Fallback";
	/* font-family: Menlo, Monaco, Consolas, "Courier New", monospace, "Droid Sans Mono", "Droid Sans Fallback"; */
	font-weight: bold;
	/* font-weight: normal */
	color: #D7BA7D;
	background-color: transparent;
}

.vscode-light pre:not(.hljs),
.vscode-light code > div { /* code block */
	font-family: Menlo, Monaco, Consolas, "Droid Sans Mono", "Courier New", monospace, "Droid Sans Fallback";
	font-weight: normal;
	background-color: #f2f2f2;
	/* background-color: rgba(220, 220, 220, 0.4); */
}

.vscode-dark pre:not(.hljs),
.vscode-dark code > div { /* code block */
	font-family: Menlo, Monaco, Consolas, "Droid Sans Mono", "Courier New", monospace, "Droid Sans Fallback";
	font-weight: normal;
	background-color: rgba(10, 10, 10, 0.4);
}

.vscode-high-contrast pre:not(.hljs),
.vscode-high-contrast code > div { /* code block */
	background-color: rgb(0, 0, 0);
}

.vscode-high-contrast h1 {
	border-color: rgb(0, 0, 0);
}

.vscode-light table > thead > tr > th {
	border-color: rgba(0, 0, 0, 0.69);
}

.vscode-dark table > thead > tr > th {
	border-color: rgba(255, 255, 255, 0.69);
}

.vscode-light h1,
.vscode-light hr,
.vscode-light table > tbody > tr + tr > td {
	border-color: rgba(0, 0, 0, 0.18);
}

.vscode-dark h1,
.vscode-dark hr,
.vscode-dark table > tbody > tr + tr > td {
	border-color: rgba(255, 255, 255, 0.18);
}

.vscode-light blockquote,
.vscode-dark blockquote {
	background: transparent;
	border-color: rgba(70, 70, 70, 0.2);
}

.vscode-high-contrast blockquote {
	background: transparent;
	border-color: #fff;
}
/* Base16 Atelier Forest Light - Theme */
/* by Bram de Haan (http://atelierbram.github.io/syntax-highlighting/atelier-schemes/forest) */
/* Original Base16 color scheme by Chris Kempson (https://github.com/chriskempson/base16) */
/* https://github.com/jmblog/color-themes-for-highlightjs */
/* Modification was made */

/* Atelier Forest Light Comment */
.hljs-comment,
.hljs-title {
 color: #766e6b;
}

/* Atelier Forest Light Red */
.hljs-variable,
.hljs-attribute,
.hljs-tag,
.hljs-regexp,
.ruby .hljs-constant,
.xml .hljs-tag .hljs-title,
.xml .hljs-pi,
.xml .hljs-doctype,
.html .hljs-doctype,
.css .hljs-id,
.css .hljs-class,
.css .hljs-pseudo {
 color: #f22c40;
}

/* Atelier Forest Light Orange */
.hljs-number,
.hljs-preprocessor,
.hljs-pragma,
.hljs-built_in,
.hljs-literal,
.hljs-constant {
 color: #1E1E1E;
}

/* Atelier Forest Light Yellow */
.hljs-ruby .hljs-class .hljs-title,
.css .hljs-rules .hljs-attribute {
 color: #d5911a;
}

.hljs-params {
 color: #f57911; 
}

/* Atelier Forest Light Green */
.hljs-string,
.hljs-value,
.hljs-inheritance,
.hljs-header,
.ruby .hljs-symbol,
.xml .hljs-cdata {
 color: #5ab738;
}

/* Atelier Forest Light Aqua */
.css .hljs-hexcolor {
 color: #00ad9c;
}

/* Atelier Forest Light Blue */
.hljs-function,
.python .hljs-decorator,
.python .hljs-title,
.ruby .hljs-function .hljs-title,
.ruby .hljs-title .hljs-keyword,
.perl .hljs-sub,
.javascript .hljs-title,
.coffeescript .hljs-title {
 color: #407ee7;
}

/* Atelier Forest Light Purple */
.hljs-keyword,
.javascript .hljs-function {
 color: #6666ea;
}

.hljs {
 display: block;
 overflow-x: auto;
 color: #68615e;
 padding: 0.5em;
 -webkit-text-size-adjust: none;
}

.coffeescript .javascript,
.javascript .xml,
.tex .hljs-formula,
.xml .javascript,
.xml .vbscript,
.xml .css,
.xml .hljs-cdata {
 opacity: 0.5;
}

/***** by jasily *****/

.hljs {
 display: block;
 overflow-x: auto;
 background: #f1efee;
 color: #68615e;
 padding: 0.5em;
 -webkit-text-size-adjust: none;
}

.hljs-keyword {
 color: #9868b6;
}

.hljs-number {
 color: #f57911;
}

.hljs-string {
 color: #70aa11;
}

.hljs-comment {
 color: #2399c6;
}

.hljs-xmlDocTag {
 color: #23CEE8;
}

.hljs-class {
 color: #1E1E1E;
}

.hljs-function {
 color: #1E1E1E;
}

.hljs-title {
 color: #4271ae;
}

.hljs-variable {
 color: #F572F0;
}
</style>
    </head>
    <body>
        <article class="markdown-body">
            <h1 id="topic-3-multithreading-4">Topic 3 Multithreading (4)</h1>
<div id="author-signature">Leedehai</div>
Monday, May 8, 2017<br>Monday, May 15, 2017
<h2 id="36-the-semaphore-class">3.6 The semaphore class</h2>
<ul>
<li><code>semaphore</code> is implemented by the instructor, a class that is meant to be a high-level abstraction of this trio in 3.5.3:<pre class="hljs"><code><div><span class="hljs-comment">/* permission slips to bid for some resource instances */</span>  
<span class="hljs-keyword">size_t</span> numAllowed;
<span class="hljs-comment">/* mutex lock to protect permission slip ++, -- */</span>
mutex m;
<span class="hljs-comment">/* condition variable: used to block and wait
   until a permission slip is available */</span>
condition_variable_any cv;
</div></code></pre>
Similar class is provided in POSIX C extension, Java, Python, .. yet missing from C++ STL.</li>
<li><code>semaphore</code> API:<pre class="hljs"><code><div><span class="hljs-comment">/* semaphore.h */</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> ...</span>

<span class="hljs-keyword">class</span> semaphore {
<span class="hljs-keyword">public</span>:
  semaphore(<span class="hljs-keyword">int</span> value = <span class="hljs-number">0</span>) : value(value) {}
  <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">signal</span><span class="hljs-params">()</span></span>; <span class="hljs-comment">/* value++ */</span> 
  <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">wait</span><span class="hljs-params">()</span></span>;   <span class="hljs-comment">/* value--, potentially blocking */</span>
<span class="hljs-keyword">private</span>:
  <span class="hljs-keyword">int</span> value;  <span class="hljs-comment">/* the number of available resource instances */</span>
  <span class="hljs-built_in">std</span>::mutex m;
  <span class="hljs-built_in">std</span>::condition_variable_any cv;

  semaphore(<span class="hljs-keyword">const</span> semaphore&amp; orig) = <span class="hljs-keyword">delete</span>;
  <span class="hljs-keyword">const</span> semaphore&amp; <span class="hljs-keyword">operator</span>=(<span class="hljs-keyword">const</span> semaphore&amp; rhs) <span class="hljs-keyword">const</span> = <span class="hljs-keyword">delete</span>;
};
</div></code></pre>
Design decsions:
<ul>
<li>
<p>The instructor designed the API such that there's no getValue-like method. Reason: in between the time you call it and act on it, some other thread could very well change it. Concurrency directives themselves shouldn't encourage anything that might lead to a race condition or a deadlock. Providing this method might encourage you to make this mistake.</p>
</li>
<li>
<p>The instructor removed the copy constructor and assignment operator (using the <code>delete</code> keyword), because neither the <code>mutex</code> nor <code>condition_variable_any</code> object is copy constructable, copy assignable, or even movable.</p>
</li>
</ul>
</li>
<li><code>semaphore</code> implementation:<pre class="hljs"><code><div><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> ...</span>

<span class="hljs-keyword">void</span> semaphore::signal() {
    <span class="hljs-built_in">std</span>::lock_guard&lt;mutex&gt; lg(m); <span class="hljs-comment">/* m.lock() to protect value */</span>
    value++;

    <span class="hljs-comment">/* notify cv that value becomes &gt; 0 */</span>
    <span class="hljs-keyword">if</span> (value == <span class="hljs-number">1</span>) cv.notify_all();
} <span class="hljs-comment">/* lock_guard, as a local, is destructed here and m is unlocked */</span>

<span class="hljs-keyword">void</span> semaphore::wait() {
    <span class="hljs-built_in">std</span>::lock_guard&lt;metex&gt; lg(m); <span class="hljs-comment">/* m.lock() to protect value */</span>

    <span class="hljs-comment">/* make sure value &gt; 0 before proceeding,
       if not, block &amp; wait here */</span>
    cv.wait(m, [<span class="hljs-keyword">this</span>]{<span class="hljs-keyword">return</span> value &gt; <span class="hljs-number">0</span>;});

    value--;
} <span class="hljs-comment">/* lock_guard, as a local, is destructed here and m is unlocked */</span>
</div></code></pre>
<ul>
<li>There is a <code>this</code> pointer in the closure of the lambda expression, because the lambda function needs the access to the <code>value</code> member, which is neither a global variable nor a local one inside the lambda function's body. Providing the <code>this</code> pointer enables the lambda function to access the <code>semaphore</code> object's scope.</li>
<li><code>mutex</code> vs. <code>semaphore(1)</code>: <code>mutex</code>es are safer in the sense that only the thread which locks it , could unlock it. Implementation of semaphore uses a <code>mutex</code> and a <code>condition_variable_any</code>, so it does the same work as a <code>mutex</code>es, but it is an overkill when a simpler thing could solve that issue.</li>
</ul>
</li>
</ul>
<h3 id="361-reimeplement-eat-in-353">3.6.1 Reimeplement <code>eat()</code> in 3.5.3</h3>
<ul>
<li>The original version of <code>eat()</code> in 3.5.3:<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">eat</span><span class="hljs-params">(<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> id)</span> </span>{
  <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> left = id;
  <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> right = (id + <span class="hljs-number">1</span>) % kNumForks;

  waitForPermission(); <span class="hljs-comment">/* wait for permission until get one */</span>

  forks[left].lock();  <span class="hljs-comment">/* may wait here */</span>
  forks[right].lock(); <span class="hljs-comment">/* may wait here */</span>

  <span class="hljs-built_in">cout</span> &lt;&lt; oslock &lt;&lt; id &lt;&lt; <span class="hljs-string">" starts eating."</span> &lt;&lt; <span class="hljs-built_in">endl</span> &lt;&lt; osunlock;
  sleep_for(getEatTime());
  <span class="hljs-built_in">cout</span> &lt;&lt; oslock &lt;&lt; id &lt;&lt; <span class="hljs-string">" all done eating."</span> &lt;&lt; <span class="hljs-built_in">endl</span> &lt;&lt; osunlock;

  grantPermission(); <span class="hljs-comment">/* give back the permission to the pool */</span>

  forks[left].unlock();
  forks[right].unlock();
}
</div></code></pre>
</li>
<li>Reimplement <code>eat()</code>: no longer need separate <code>waitForPermission()</code> and <code>grantPermission()</code> function implementations.<pre class="hljs"><code><div><span class="hljs-keyword">static</span> mutex forks[kNumForks];

<span class="hljs-comment">/* Strip out exposed size_t, mutex, and condition_variable_any,
   and replace the trio with a single semaphore object. */</span>
<span class="hljs-function"><span class="hljs-keyword">static</span> semaphore <span class="hljs-title">numAllowed</span><span class="hljs-params">(kNumForks - <span class="hljs-number">1</span>)</span></span>;

<span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">eat</span><span class="hljs-params">(<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> id)</span> </span>{
  <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> left = id;
  <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> right = (id + <span class="hljs-number">1</span>) % kNumForks;

  <span class="hljs-comment">/* atomic --, it blocks if it attempts to decrement 0 */</span>
  numAllowed.wait();

  forks[left].lock();
  forks[right].lock();
  <span class="hljs-built_in">cout</span> &lt;&lt; oslock &lt;&lt; id &lt;&lt; <span class="hljs-string">" starts eating."</span> &lt;&lt; <span class="hljs-built_in">endl</span> &lt;&lt; osunlock;
  sleep_for(getEatTime());
  <span class="hljs-built_in">cout</span> &lt;&lt; oslock &lt;&lt; id &lt;&lt; <span class="hljs-string">" all done eating."</span> &lt;&lt; <span class="hljs-built_in">endl</span> &lt;&lt; osunlock;

  <span class="hljs-comment">/* atomic ++, no block, possibly unblocks other waiting threads */</span>
  numAllowed.signal();

  forks[left].unlock();
  forks[right].unlock();
}
</div></code></pre>
</li>
</ul>
<blockquote>
<p>For exams (KOB):<br>(1) State the many pros on this approach over the busy waiting approach we initially used to avert the threat of deadlock in 3.5.2.<br>(2) Can you think of any situations when busy-waiting might be the right approach?</p>
</blockquote>
<h2 id="37-readerwriter-problem-kob">3.7 Reader–writer problem (KOB)</h2>
<blockquote>
<p>This problem describes a situation where threads are trying to access the same shared resource at one time. Also referred to as the <em>consumer-producer problem</em> in a more generic sense.<br>It is different from the dining philosophers problem, where threads are bidding resource instances in a directed-cyclic-graph pattern.</p>
</blockquote>
<p>Say there is a webpage content generator - the writer, and a browser to parse and render webpage's content - the reader. There is a buffer, whose capacity is <code>8</code> characters, and there are <code>40</code> characters to transmit in total. Obviously, the content cannot be delivered in an one-time transmission.</p>
<ul>
<li>We want the writer and reader to work in synchronization, so that the reader is consuming characters from the buffer while the writer is populating it.</li>
<li>We also want to make sure that <strong>the writer is ahead of the reader</strong> (so the reader fail at getting a character from the buffer), <strong>but by not too much</strong> (so the buffer won't overflow).</li>
<li>Obviously, an intuitive solution is having two child threads - one for the writer and the other for the reader. The buffer is the resource the two threads are sharing, and there are <code>8</code> character slots in that buffer.</li>
<li>To make sure they work in synchronization (<strong>no race condition nor deadlock</strong>), we can use <code>semaphore</code> classes to enforce it.
<ul>
<li>Before the writer can write a character to the buffer, it has to lock the intended character slot. If no slot is available (i.e. not been read yet), it has to wait until one becomes so.</li>
<li>Before the reader can read a character from the buffer, it has to lock the intended character slot. If no slot is available (i.e. not been written yet), it has to wait until one becomes so.</li>
<li>Since <strong>there are two conditions that will put a thread into wait</strong>, we have to use two <code>semaphore</code> objects, as opposed to only one.
<ul>
<li>One <code>semaphore</code> object is <code>full</code>, and its initial <code>value</code> is <code>0</code>, denoting there is 0 slot that are full at the beginning.</li>
<li>The other <code>semaphore</code> object is <code>empty</code>, and its initial <code>value</code> is <code>8</code>, denoting there are 8 slots that are empty at the beginning.</li>
</ul>
<blockquote>
<p>It's like two dogs, whose sweater are marked &quot;r&quot; and &quot;w&quot; respectively, are running along a road, given that<br>(1) if &quot;r&quot; catches up with &quot;w&quot;, &quot;r&quot; will stop and wait for &quot;w&quot; to run for a while, so &quot;w&quot; is ahead of &quot;r&quot;;<br>(2) if &quot;w&quot; is too far ahead of &quot;r&quot;, &quot;w&quot; will stop and wait for &quot;r&quot; to run for a while, so &quot;r&quot; is not lagging too behind.</p>
</blockquote>
</li>
</ul>
</li>
</ul>
<p>The main function:</p>
<pre class="hljs"><code><div><span class="hljs-comment">/* main.cc */</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> ...</span>
<span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;

<span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">writer</span><span class="hljs-params">()</span></span>;
<span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">reader</span><span class="hljs-params">()</span></span>;

<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{
    <span class="hljs-comment">/* spawn off two child threads */</span>
    <span class="hljs-function">thread <span class="hljs-title">w</span><span class="hljs-params">(writer)</span></span>;
    <span class="hljs-function">thread <span class="hljs-title">r</span><span class="hljs-params">(reader)</span></span>;
    <span class="hljs-comment">/* join the child threads - don't forget */</span>
    w.join();
    r.join();

    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}
</div></code></pre>
<p>The implementation of the thread routines.</p>
<pre class="hljs"><code><div><span class="hljs-comment">/* routines.cc */</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> ...</span>
<span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;

<span class="hljs-keyword">static</span> <span class="hljs-keyword">const</span> <span class="hljs-keyword">size_t</span> kNumTotalChars = <span class="hljs-number">40</span>;
<span class="hljs-keyword">static</span> <span class="hljs-keyword">const</span> <span class="hljs-keyword">size_t</span> kBufferSize = <span class="hljs-number">8</span>;
<span class="hljs-keyword">static</span> <span class="hljs-keyword">char</span> buffer[kBufferSize];

<span class="hljs-function">semaphore <span class="hljs-title">full</span><span class="hljs-params">(<span class="hljs-number">0</span>)</span></span>;
<span class="hljs-function">semaphore <span class="hljs-title">empty</span><span class="hljs-params">(kBufferSize)</span></span>; <span class="hljs-comment">/* or pass in a smaller positive number */</span>

<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">writer</span><span class="hljs-params">()</span> </span>{
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">size_t</span> i = <span class="hljs-number">0</span>; i &lt; kNumTotalChars; i++) {
        <span class="hljs-comment">/* lock one empty slot. If none is empty, wait */</span>
        empty.wait();

        buffer[i % kBufferSize] = generateOneChar();

        <span class="hljs-comment">/* increment the number of full slots by 1 */</span>
        full.signal();
    }
}

<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">reader</span><span class="hljs-params">()</span> </span>{
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">size_t</span> i = <span class="hljs-number">0</span>; i &lt; kNumTotalChars; i++) {
        <span class="hljs-comment">/* lock one full slot. If none is full, wait */</span>
        full.wait();

        <span class="hljs-keyword">char</span> ch = buffer[i % kBufferSize];
        parseOneChar(ch);
        <span class="hljs-comment">/* increment the number of empty slots by 1 */</span>
        empty.signal();
    }
}
</div></code></pre>
<ul>
<li>If the argument passed into the constructor of the <code>empty</code> object is also <code>0</code>, then the program will be entrenched in a deadlock, since each of the two <code>semaphore</code> objects are waiting one another's <code>value</code> to become positive so it can decrement its own <code>value</code>.
<blockquote>
<p>It's like the two aforementioned dogs are waiting on each other to run, so none of them is able to make any progress.</p>
</blockquote>
</li>
</ul>
<h2 id="38-myth-buster-an-example-for-load-balancer">3.8 <code>myth-buster</code>: an example for load balancer</h2>
<ul>
<li>Gist: connects to all 32 <code>myth</code> machines on Stanford campus and asks each for the total number of processes being run by CS110 students.
<blockquote>
<p>This is part of what a <a href="https://en.wikipedia.org/wiki/Load_balancing_(computing)">load balancer</a> does - get the process counts for each physical machine.</p>
</blockquote>
</li>
</ul>
<h3 id="381-sequential-version-slow-1-min">3.8.1 Sequential version: slow (~1 min)</h3>
<pre class="hljs"><code><div><span class="hljs-comment">/* Sequential: slow */</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> ...</span>
<span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;

<span class="hljs-keyword">static</span> <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">short</span> kMinMythMachine = <span class="hljs-number">1</span>;
<span class="hljs-keyword">static</span> <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">short</span> kMaxMythMachine = <span class="hljs-number">32</span>;

<span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">compileCS110ProcessCountMap</span><span class="hljs-params">(
                <span class="hljs-keyword">const</span> <span class="hljs-built_in">unordered_set</span>&lt;<span class="hljs-built_in">string</span>&gt;&amp; cs110studentIDs,
                <span class="hljs-built_in">map</span>&lt;<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">short</span>, <span class="hljs-keyword">size_t</span>&gt;&amp; counts)</span> </span>{
  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">short</span> num = kMinMythMachine;
       num &lt;= kMaxMythMachine;
       num++) {
    <span class="hljs-keyword">int</span> numProcesses = getNumProcesses(num, cs110studentIDs);
    <span class="hljs-keyword">if</span> (numProcesses &gt;= <span class="hljs-number">0</span>) { <span class="hljs-comment">/* -1 expresses networking failure */</span>
      counts[num] = numProcesses;
      <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"myth"</span> &lt;&lt; num &lt;&lt; <span class="hljs-string">" has this many CS110-student processes: "</span> 
           &lt;&lt; numProcesses &lt;&lt; <span class="hljs-built_in">endl</span>;
    }
  }
}
</div></code></pre>
<p>Nothing interesting here. The program just traverse all the machines. It is understandably slow (~1 min), since communication over the Internet is slow.</p>
<h3 id="382-parallel-version-faster-9-sec">3.8.2 Parallel version: faster (~9 sec)</h3>
<blockquote>
<p>Parallelism can be implemented with multiprocessing or multithreading. We go for the latter here.</p>
</blockquote>
<blockquote>
<p>When you <code>ssh</code> to a <code>myth</code> machine, you certainly don't like waiting ~1 minute for the load balancer to assign you a machine.</p>
</blockquote>
<pre class="hljs"><code><div><span class="hljs-comment">/* Multithreading: faster */</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> ...</span>
<span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;

<span class="hljs-comment">/* globals (in heap, not in stack) to share across threads */</span>
<span class="hljs-keyword">const</span> <span class="hljs-built_in">unordered_set</span>&lt;<span class="hljs-built_in">string</span>&gt; cs110studentIDs;
<span class="hljs-built_in">map</span>&lt;<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">short</span>, <span class="hljs-keyword">size_t</span>&gt; counts;
<span class="hljs-keyword">static</span> mutex processCountMapLock;


<span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">countCS110Processes</span><span class="hljs-params">(<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">short</span> num, semaphore&amp; s)</span> </span>{
  <span class="hljs-keyword">int</span> numProcesses = getNumProcesses(num, cs110studentIDs);
  <span class="hljs-keyword">if</span> (numProcesses &gt;= <span class="hljs-number">0</span>) {

    processCountMapLock.lock(); <span class="hljs-comment">/* write to the shared: lock it first! */</span>
    processCountMap[num] = numProcesses;
    processCountMapLock.unlock(); <span class="hljs-comment">/* done writing: unlock */</span>

    <span class="hljs-built_in">cout</span> &lt;&lt; oslock 
         &lt;&lt; <span class="hljs-string">"myth"</span> &lt;&lt; num &lt;&lt; <span class="hljs-string">" has this many CS110-student processes: "</span>
         &lt;&lt; numProcesses &lt;&lt; <span class="hljs-built_in">endl</span>
         &lt;&lt; osunlock;
  }

  <span class="hljs-comment">/* the thread completes and returns its permission slip back */</span>
  s.signal(on_thread_exit);
  <span class="hljs-comment">/* s.signal(on_thread_exit) signals the semaphore ON the thread's
   * exit; s.signal() does so BEFORE the thread's exit,
   * but this thread may not be truely done yet.
   */</span>
}

<span class="hljs-keyword">static</span> <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">short</span> kMinMythMachine = <span class="hljs-number">1</span>;
<span class="hljs-keyword">static</span> <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">short</span> kMaxMythMachine = <span class="hljs-number">32</span>;
<span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> kMaxNumThrds = <span class="hljs-number">8</span>; <span class="hljs-comment">/* max. number of child threads at a time */</span>

<span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">compileCS110ProcessCountMap</span><span class="hljs-params">()</span> </span>{
  <span class="hljs-built_in">vector</span>&lt;thread&gt; threads;

  <span class="hljs-comment">/* used to limit number of threads */</span>
  <span class="hljs-function">semaphore <span class="hljs-title">numAllowed</span><span class="hljs-params">(kMaxNumThrds)</span></span>;

  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">short</span> num = kMinMythMachine;
       num &lt;= kMaxMythMachine;
       num++) {
    <span class="hljs-comment">/* wait for a permission to create a new child thread */</span>
    numAllowed.wait();
    threads.push_back(thread(countCS110Processes, num, ref(numAllowed)));
  }

  <span class="hljs-keyword">for</span> (thread&amp; t: threads) t.join(); <span class="hljs-comment">/* remember to reap the zombies */</span>
}
</div></code></pre>
<p>Also, the lines below ...</p>
<pre class="hljs"><code><div>processCountMapLock.lock(); <span class="hljs-comment">/* write to the shared: lock it first! */</span>
processCountMap[num] = numProcesses;
processCountMapLock.unlock(); <span class="hljs-comment">/* done writing: unlock */</span>
</div></code></pre>
<p>... could be replaced with</p>
<pre class="hljs"><code><div>lock_guard&lt;mutex&gt; lg(processCountMapLock); <span class="hljs-comment">/* the constructor locks it */</span>
processCountMap[num] = numProcesses;
<span class="hljs-comment">/* the lock is unlokced when the "lg" object is destroyed */</span>
</div></code></pre>
<blockquote>
<p>A good practice: limit the maximum number of threads allowed at a time, to prevent stack-overflowing the process, overwhelming the kernel's thread manager, or overwhelming the web server your program is connecting to.<br>The OS may also impose this limit - when threads are too many, thread creating requests will be denied.</p>
</blockquote>
<blockquote>
<p>SIDE NOTE:<br>In fact, however, for <code>myth</code> and big networks like Google, FaceBook, Microsoft, etc., users are still not satisfied with this performance - they don't want to wait for a second! So a common practice is having the load balancer run the program periodically and pre-compute the assignment.</p>
</blockquote>
<blockquote>
<p>C++ grammar in object-oriented multithreading: pass in a thread routine: say, inside a class <code>A</code>'s method function, you want to install <code>A</code> class's another method <code>void foobar(int number, semaphore &amp;s)</code> as the thread routine, the function pointer can be pushed through a thread constructor in one of the three ways listed below:</p>
</blockquote>
<pre class="hljs"><code><div> <span class="hljs-function">thread <span class="hljs-title">t</span><span class="hljs-params">([<span class="hljs-keyword">this</span>, n, &amp;sem] { <span class="hljs-keyword">this</span>-&gt;foobar(n, sem)</span></span>; }); <span class="hljs-comment">/* 1st way */</span>

 <span class="hljs-function">thread <span class="hljs-title">t</span><span class="hljs-params">([<span class="hljs-keyword">this</span>](<span class="hljs-keyword">int</span> number, semaphore &amp;s)</span> </span>{
    <span class="hljs-keyword">this</span>-&gt;foobar(number, s)
 }, n, ref(sem)); <span class="hljs-comment">/* 2nd way */</span>

 <span class="hljs-function">thread <span class="hljs-title">t</span><span class="hljs-params">(&amp;A::foobar, <span class="hljs-keyword">this</span>, n, ref(sem)</span>)</span>; <span class="hljs-comment">/* 3rd way */</span>

 <span class="hljs-comment">/* The template function ref() explicitly tells the compiler
  * "I'm passing by reference, not by value!", as the compiler
  * does not do type-matching for "thread" class constructor's
  * variadic argument list.
  */</span>
 <span class="hljs-comment">/* mutex and semaphore objects are not copiable. Their copy-constructors
  * are explicitly deleted in their class declarations */</span>
</div></code></pre>
<h6 id="eof">EOF</h6>

        </article>
    </body>
</html>